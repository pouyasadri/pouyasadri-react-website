{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar type_1 = __importDefault(require(\"./nodes/type\"));\nfunction isTag(node) {\n  return node && node.nodeType === type_1.default.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n  return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n  return (elem && elem.rawTagName || '').toLowerCase();\n}\nfunction getChildren(node) {\n  return node && node.childNodes;\n}\nfunction getParent(node) {\n  return node ? node.parentNode : null;\n}\nfunction getText(node) {\n  return node.text;\n}\nfunction removeSubsets(nodes) {\n  var idx = nodes.length;\n  var node;\n  var ancestor;\n  var replace;\n  // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n  while (--idx > -1) {\n    node = ancestor = nodes[idx];\n    // Temporarily remove the node under consideration\n    nodes[idx] = null;\n    replace = true;\n    while (ancestor) {\n      if (nodes.indexOf(ancestor) > -1) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n      ancestor = getParent(ancestor);\n    }\n    // If the node has been found to be unique, re-insert it.\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n  return nodes;\n}\nfunction existsOne(test, elems) {\n  return elems.some(function (elem) {\n    return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n  });\n}\nfunction getSiblings(node) {\n  var parent = getParent(node);\n  return parent ? getChildren(parent) : [];\n}\nfunction hasAttrib(elem, name) {\n  return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n  var elem = null;\n  for (var i = 0, l = elems === null || elems === void 0 ? void 0 : elems.length; i < l && !elem; i++) {\n    var el = elems[i];\n    if (test(el)) {\n      elem = el;\n    } else {\n      var childs = getChildren(el);\n      if (childs && childs.length > 0) {\n        elem = findOne(test, childs);\n      }\n    }\n  }\n  return elem;\n}\nfunction findAll(test, nodes) {\n  var result = [];\n  for (var i = 0, j = nodes.length; i < j; i++) {\n    if (!isTag(nodes[i])) continue;\n    if (test(nodes[i])) result.push(nodes[i]);\n    var childs = getChildren(nodes[i]);\n    if (childs) result = result.concat(findAll(test, childs));\n  }\n  return result;\n}\nexports.default = {\n  isTag: isTag,\n  getAttributeValue: getAttributeValue,\n  getName: getName,\n  getChildren: getChildren,\n  getParent: getParent,\n  getText: getText,\n  removeSubsets: removeSubsets,\n  existsOne: existsOne,\n  getSiblings: getSiblings,\n  hasAttrib: hasAttrib,\n  findOne: findOne,\n  findAll: findAll\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","type_1","require","isTag","node","nodeType","default","ELEMENT_NODE","getAttributeValue","elem","name","getAttribute","undefined","getName","rawTagName","toLowerCase","getChildren","childNodes","getParent","parentNode","getText","text","removeSubsets","nodes","idx","length","ancestor","replace","indexOf","splice","existsOne","test","elems","some","getSiblings","parent","hasAttrib","findOne","i","l","el","childs","findAll","result","j","push","concat"],"sources":["/Users/pouyasadri/pouyasari-react-master/node_modules/node-html-parser/dist/matcher.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar type_1 = __importDefault(require(\"./nodes/type\"));\nfunction isTag(node) {\n    return node && node.nodeType === type_1.default.ELEMENT_NODE;\n}\nfunction getAttributeValue(elem, name) {\n    return isTag(elem) ? elem.getAttribute(name) : undefined;\n}\nfunction getName(elem) {\n    return ((elem && elem.rawTagName) || '').toLowerCase();\n}\nfunction getChildren(node) {\n    return node && node.childNodes;\n}\nfunction getParent(node) {\n    return node ? node.parentNode : null;\n}\nfunction getText(node) {\n    return node.text;\n}\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    var node;\n    var ancestor;\n    var replace;\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while (--idx > -1) {\n        node = ancestor = nodes[idx];\n        // Temporarily remove the node under consideration\n        nodes[idx] = null;\n        replace = true;\n        while (ancestor) {\n            if (nodes.indexOf(ancestor) > -1) {\n                replace = false;\n                nodes.splice(idx, 1);\n                break;\n            }\n            ancestor = getParent(ancestor);\n        }\n        // If the node has been found to be unique, re-insert it.\n        if (replace) {\n            nodes[idx] = node;\n        }\n    }\n    return nodes;\n}\nfunction existsOne(test, elems) {\n    return elems.some(function (elem) {\n        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;\n    });\n}\nfunction getSiblings(node) {\n    var parent = getParent(node);\n    return parent ? getChildren(parent) : [];\n}\nfunction hasAttrib(elem, name) {\n    return getAttributeValue(elem, name) !== undefined;\n}\nfunction findOne(test, elems) {\n    var elem = null;\n    for (var i = 0, l = elems === null || elems === void 0 ? void 0 : elems.length; i < l && !elem; i++) {\n        var el = elems[i];\n        if (test(el)) {\n            elem = el;\n        }\n        else {\n            var childs = getChildren(el);\n            if (childs && childs.length > 0) {\n                elem = findOne(test, childs);\n            }\n        }\n    }\n    return elem;\n}\nfunction findAll(test, nodes) {\n    var result = [];\n    for (var i = 0, j = nodes.length; i < j; i++) {\n        if (!isTag(nodes[i]))\n            continue;\n        if (test(nodes[i]))\n            result.push(nodes[i]);\n        var childs = getChildren(nodes[i]);\n        if (childs)\n            result = result.concat(findAll(test, childs));\n    }\n    return result;\n}\nexports.default = {\n    isTag: isTag,\n    getAttributeValue: getAttributeValue,\n    getName: getName,\n    getChildren: getChildren,\n    getParent: getParent,\n    getText: getText,\n    removeSubsets: removeSubsets,\n    existsOne: existsOne,\n    getSiblings: getSiblings,\n    hasAttrib: hasAttrib,\n    findOne: findOne,\n    findAll: findAll\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}